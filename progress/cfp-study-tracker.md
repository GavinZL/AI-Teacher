# C++ 能力进度总览（CFP Study Tracker）

## Domain Progress（按 Role.md 的 8 个大类）

| 域编号 | 领域                        | 权重 | 状态              | 备注 |
|--------|-----------------------------|------|-------------------|------|
| 1      | 语言核心与对象模型          | 20% | 进行中            | 12-17: 类型系统、引用与值类别；12-27: 移动语义、三五零法则；26-01-04: 对象语义/值语义/引用语义与 API 设计 |
| 2      | 并发与内存模型              | 18% | 未开始/待规划     |      |
| 3      | 模板与泛型                  | 15% | 进行中            | 12-28: 完美转发、引用折叠；元编程待补 |
| 4      | 性能与优化                  | 12% | 进行中            | 12-27: 移动语义深入理解，RVO/NRVO 待实战；26-01-04: Buffer 语义与 vector 扩容中的移动/noexcept 行为 |
| 5      | 现代 C++ 新特性             | 10% | 未开始/待规划     |      |
| 6      | STL 与算法                  | 10% | 进行中            | 常用容器/算法没问题，复杂度 & 并行算法待补 |
| 7      | 工程实践                    | 8%  | 进行中            | CMake/单测/CI 视项目再记 |
| 8      | 调试与排查                  | 7%  | 进行中（工具零散）| 具体工具使用经验待整理 |

_Last Updated: 2026-01-04_

---

# Topics Mastered

### [2025-12-17]

- **C++ 类型系统整体视角（语言核心与对象模型）**  
  - **置信度**：中等偏上（概念已通，需通过多题/多代码场景加固）  
  - **关键点**：
    - 类型不等于"占多少字节"，而是"值域 + 可用操作 + 编译期检查 + ABI 布局"；
    - 区分"类型分类"（对象类型 / 函数类型 / 引用类型 / cv 限定）与"表达式值类别"（lvalue / rvalue / xvalue / prvalue）；
    - 引用是别名，不是独立对象，引入的主要目的是表达语义和性能（避免不必要拷贝）；
    - 生命周期延长：当临时右值绑定到 `const T&` 或 `T&&` 时，被绑定临时对象活到引用作用域结束；绑定已有左值不会改变生命周期；
    - `auto` 默认值语义，会抹掉顶层 `cv` 和引用信息，如需保留引用必须显式写 `auto&` / `auto&&`。
  - **代码参考**：见 `sessions/2025-12-17/session-notes.md` 中的示例代码。

### [2025-12-27]

- **移动语义与右值引用（语言核心与对象模型 + 性能与优化）**  
  - **置信度**：中等偏高（核心概念清晰，实战应用需要更多练习）  
  - **关键点**：
    - 移动语义的双重价值：性能优化（避免深拷贝）+ 语义表达（支持只能移动的类型如 `std::unique_ptr`）；
    - `std::move` 本质是类型转换（cast），将表达式从左值转为右值引用（xvalue），不做实际资源转移；
    - 右值引用 `T&&` 只是"可以被移动"的信号，实际移动操作由移动构造/移动赋值函数完成；
    - moved-from 对象状态：标准规定为"有效但未指定"，可以安全析构和重新赋值，但不能假设其值；
    - 移动构造 vs 移动赋值：前者初始化新对象（不需要释放旧资源、不需要自赋值检查），后者操作已存在对象（需要先释放旧资源、必须检查自赋值）；
    - 三五零法则：Rule of Three（析构/拷贝构造/拷贝赋值）、Rule of Five（+ 移动构造/移动赋值）、Rule of Zero（用 RAII 类自动管理）；
    - 工业级移动函数要点：必须 `noexcept`、移动赋值需自赋值检查、用 `std::exchange` 保证原子性。
  - **代码参考**：见 `sessions/2025-12-27/session-notes.md` 中的详细代码示例。

### [2025-12-28]

- **完美转发与引用折叠（模板与泛型）**  
  - **置信度**：高（核心机制全面掌握，实战应用需要更多练习）  
  - **关键点**：
    - 完美转发的核心问题：在模板函数中保持参数的值类别（左值/右值）不变；
    - 引用折叠规则：`& &` → `&`、`& &&` → `&`、`&& &` → `&`、`&& &&` → `&&`（只要有一个 `&` 就折叠成 `&`）；
    - 转发引用（Forwarding Reference）：模板参数 `T&&` 在类型推导时才是转发引用，可以绑定左值和右值；
    - 推导机制：传入左值时 `T` 推导为引用类型（如 `int&`），传入右值时 `T` 推导为非引用类型（如 `int`）；
    - `std::forward` vs `std::move`：前者根据 `T` 的类型有条件地转换，后者无条件转为右值引用；
    - 典型应用：工厂函数（`std::make_unique`）、`emplace_back`、包装函数；
    - 常见陷阱：转发引用只在类型推导时生效、一次转发原则、不能转发位域、`auto&&` 也是转发引用。
  - **代码参考**：见 `sessions/2025-12-28/session-notes.md` 中的详细代码示例。

### [2026-01-04]

- **对象语义：构造 / 拷贝 / 移动 + 值语义 vs 引用语义（语言核心与对象模型 + 性能与优化）**  
  - **置信度**：中等偏高（语义框架已建立，后续需要更多代码与题目加固）  
  - **关键点**：
    - 把“语义”统一理解为行为合同：描述对象在构造 / 拷贝 / 移动 / 析构时的状态变化、资源所有权变化、代价和触发时机，而不是语法细节；
    - 使用 `Buffer` 示例抽象出构造语义（资源获取与不变量）、拷贝语义（深拷贝 + 资源独立 + O(n)）、移动语义（所有权转移 + moved-from 有效但未指定状态 + O(1)）的清晰合同；
    - 通过 `std::vector<Buffer>` 的扩容场景理解 `noexcept` 移动构造对容器行为的影响：只有移动是 `noexcept` 时，`vector` 才敢在扩容中优先采用移动，显著降低成本；
    - 建立值语义 vs 引用语义的统一类比：值语义像“现金”（拷贝产生独立副本，如 `Image`），引用语义像“银行卡”（拷贝产生多个句柄共享同一底层对象，如 `ImageHandle`、`std::string_view`）；
    - 理解 `std::unique_ptr` 是“带唯一所有权的移动值语义”：拷贝被禁用，只能移动转移所有权；
    - 从 API 设计视角区分：`process(Image)` 更像处理副本，`processHandle(ImageHandle)` 更像对共享对象施加可能有副作用的操作，即便二者都是按值传参；
    - 利用 `make_vec` 示例理解 C++17 下 RVO/NRVO 与移动语义的关系：返回局部对象通常直接构造到目标位置，只有 RVO 不适用时才会退化为移动或拷贝。
  - **代码参考**：见 `sessions/2026-01-04/session-notes.md` 中的详细记录与示例。

---

# Knowledge Gaps（当前主要空白/待强化点）

- **表达式值类别的标准术语与判定**  
  - 现状：知道左值 / 右值的直觉含义，但对 prvalue / xvalue 的精确定义和典型例子不够熟；
  - 风险：在讲移动语义、完美转发时容易只能"感性描述"，说不出标准细节和边界；
  - 目标：能用几行代码说明每类表达式的典型例子，并解释为什么属于该类别。

- **`auto` / `decltype` / `decltype(auto)` 统一视角**  
  - 现状：知道 `auto` 会丢掉引用，但还没完全建立"模板推导视角"的心智模型；
  - 风险：遇到复杂泛型代码时，对类型推导结果需要频繁试错；
  - 目标：能手算常见几类表达式下的推导结果，并能用"把 `auto` 看成模板参数 T"来快速解释原因。

- **完美转发与引用折叠规则**（已掌握）  
  - 现状：已系统掌握引用折叠表、转发引用的推导机制、`std::forward` 的原理；
  - 下一步：在实际项目中应用完美转发（工厂函数、包装类），结合 C++20 `concept` 约束转发引用。

- **RVO/NRVO 与移动语义的关系**（新增）  
  - 现状：知道编译器会优化返回值，但不清楚什么情况下会触发 RVO、什么情况下退化成移动或拷贝；
  - 风险：在写返回临时对象的函数时，不确定要不要用 `std::move`，可能反而阻止编译器优化；
  - 目标：能判断具体场景下的优化策略，知道何时不应该用 `std::move`。

- **异常安全保证在移动函数中的实现**（新增）  
  - 现状：知道移动函数要标记 `noexcept`，但对强保证、基本保证的具体实现细节不够清晰；
  - 风险：自己实现移动函数时可能出现资源泄漏或状态不一致；
  - 目标：能解释为什么 `std::exchange` 能提供更好的异常安全，能写出异常安全的移动赋值函数。

- **可变参数模板与折叠表达式**（新增）  
  - 现状：知道 `Args&&...` 的基本用法，但对 C++17 折叠表达式的高级用法不熟悉；
  - 风险：写可变参数模板时只能用递归展开，代码复杂；
  - 目标：掌握 C++17 折叠表达式（`(... op pack)`）的用法，简化可变参数处理。

---

# Study Plan（按权重与当前进度）

短期（接下来几次会话优先级）：

1. **性能与优化**（权重 12%，移动语义已入门，需实战）
   - 任务：
     - 实战：写一个持有动态数组的类，实现完整的五个特殊成员函数（Rule of Five）；
     - **Benchmark 对比**：拷贝 vs 移动的性能差异，STL 容器扩容时的移动优化；
     - **RVO/NRVO 实验**：结合 Godbolt 或本地编译，测试返回临时对象时编译器的优化行为，理解何时不应该用 `std::move`。

2. **模板与泛型**（权重 15%，完美转发已掌握）
   - 任务：
     - 用模板参数视角重写 `auto` 推导例子，练习手算推导；
     - **实战应用**：写一个简单的工厂函数模板，结合完美转发与可变参数；
     - 学习 C++17 折叠表达式，简化可变参数处理；
     - 练习转发引用与 SFINAE / C++20 `concept` 的结合。

3. **语言核心与对象模型**（权重 20%，继续加深）
   - 任务：
     - 正式梳理表达式值类别：给出 3~5 段小代码，逐行标注每个表达式是 lvalue / xvalue / prvalue；
     - 补充"对象模型"部分：对象存储期（自动/静态/动态/临时）、POD / 标准布局类型的基本概念；
     - 异常安全保证：强保证、基本保证在 RAII 和移动语义中的应用。

中期（在并发前完成）：

4. **STL 与算法**（权重 10%）
   - 任务：
     - 深入容器复杂度：`std::vector` 扩容机制、`std::unordered_map` 的哈希冲突处理；
     - 移动语义在 STL 中的应用：`emplace_back` vs `push_back`、`std::move_iterator` 的使用场景。

---

> 说明：本文件作为 C++ 能力总览，不记录具体对话细节，所有当天细节和代码请参见对应日期下的 `sessions/YYYY-MM-DD/session-notes.md`。
